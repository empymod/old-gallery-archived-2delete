.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_gallery_comparisons_1D_VTI_empymod.py>`     to download the full example code
    .. rst-class:: sphx-glr-example-title

    .. _sphx_glr_gallery_comparisons_1D_VTI_empymod.py:


1. empymod: 1D VTI resistivity
==============================

The code ``empymod`` is an open-source code which can model CSEM responses for
a layered medium including VTI electrical anisotropy, see `empymod.github.io
<https://empymod.github.io>`_.

Content:

1. Full-space VTI model for a finite length, finite strength, rotated bipole.

  a. Regular VTI case
  b. Tri-axial anisotropy check: Swap ``x`` and ``z`` in ``emg3d``; compare
     ``yz``-slice
  c. Tri-axial anisotropy check: Swap ``y`` and ``z`` in ``emg3d``; compare
     ``xz``-slice

2. Layered model for a deep water model with a point dipole source.


.. code-block:: default

    import emg3d
    import empymod
    import numpy as np
    import matplotlib.pyplot as plt
    from scipy import interpolate as sint
    from matplotlib.colors import LogNorm, SymLogNorm
    plt.style.use('ggplot')










.. code-block:: default

    def plot_data_rel(ax, name, data, x, vmin=-15., vmax=-7., mode="log"):
        """Plot function."""

        ax.set_title(name)
        ax.set_xlim(min(x)/1000, max(x)/1000)
        ax.set_ylim(min(x)/1000, max(x)/1000)
        ax.axis("equal")

        if isinstance(mode, str):
            if mode == "abs":
                cf = ax.pcolormesh(
                        x/1000, x/1000, np.log10(np.abs(data)), linewidth=0,
                        rasterized=True, cmap="viridis", vmin=vmin, vmax=vmax)
            else:
                cf = ax.pcolormesh(
                        x/1000, x/1000, data, linewidth=0, rasterized=True,
                        cmap="PuOr_r",
                        norm=SymLogNorm(linthresh=10**vmin,
                                        vmin=-10**vmax, vmax=10**vmax))
        else:
            cf = ax.pcolormesh(
                    x/1000, x/1000, np.log10(data), vmin=vmin, vmax=vmax,
                    linewidth=0, rasterized=True,
                    cmap=plt.cm.get_cmap("RdBu_r", 8))

        return cf










.. code-block:: default

    def plot_result_rel(depm, de3d, x, title, vmin=-15., vmax=-7., mode="log"):
        fig, axs = plt.subplots(figsize=(18, 10), nrows=2, ncols=3)

        if mode == "log":
            case = ""
        else:
            case = "|"

        # Plot Re(data)
        cf0 = plot_data_rel(axs[0, 0], r"(a) "+case+"Re(empymod)"+case,
                            depm.real, x, vmin, vmax, mode)
        plot_data_rel(axs[0, 1], r"(b) "+case+"Re(emg3d)"+case,
                      de3d.real, x, vmin, vmax, mode)
        cf2 = plot_data_rel(axs[0, 2], r"(c) Error real part",
                            np.abs((depm.real-de3d.real)/depm.real)*100, x,
                            vmin=-2, vmax=2, mode=True)

        # Plot Im(data)
        plot_data_rel(axs[1, 0], r"(d) "+case+"Im(empymod)"+case,
                      depm.imag, x, vmin, vmax, mode)
        plot_data_rel(axs[1, 1], r"(e) "+case+"Im(emg3d)"+case,
                      de3d.imag, x, vmin, vmax, mode)
        plot_data_rel(axs[1, 2], r"(f) Error imaginary part",
                      np.abs((depm.imag-de3d.imag)/depm.imag)*100,
                      x, vmin=-2, vmax=2, mode=True)

        # Colorbars
        fig.colorbar(cf0, ax=axs[0, :], label=r"$\log_{10}$ Amplitude (V/m)")
        cbar = fig.colorbar(cf2, ax=axs[1, :], label=r"Relative Error")
        cbar.set_ticks([-2, -1, 0, 1, 2])
        cbar.ax.set_yticklabels([r"$0.01\,\%$", r"$0.1\,\%$", r"$1\,\%$",
                                 r"$10\,\%$", r"$100\,\%$"])

        # Axis label
        fig.text(0.4, 0.05, "Inline Offset (km)", fontsize=14)
        fig.text(0.08, 0.6, "Crossline Offset (km)", rotation=90, fontsize=14)

        # Title
        fig.suptitle(title, y=1, fontsize=20)
        plt.show()










.. code-block:: default

    def plot_lineplot_ex(x, y, data, epm_fs, grid):
        xi = x.size//2
        yi = y.size//2

        fn = sint.interp1d(x, data[:, xi], bounds_error=False)
        x1 = fn(grid.vectorNx)

        fn = sint.interp1d(y, data[yi, :], bounds_error=False)
        y1 = fn(grid.vectorNx)

        plt.figure(figsize=(15, 8))

        plt.plot(x/1e3, np.abs(epm_fs[:, xi]), 'C0', lw=3, label='Inline empymod')
        plt.plot(x/1e3, np.abs(data[:, xi]), 'k--', label='Inline emg3d')
        plt.plot(grid.vectorNx/1e3, np.abs(x1), 'k*')

        plt.plot(y/1e3, np.abs(epm_fs[yi, :]), 'C1', lw=3,
                 label='Crossline empymod')
        plt.plot(y/1e3, np.abs(data[yi, :]), 'k:', label='Crossline emg3d')
        plt.plot(grid.vectorNx/1e3, np.abs(y1), 'k*', label='Grid points emg3d')

        plt.yscale('log')
        plt.title(r'Inline and crossline $E_x$', fontsize=20)
        plt.xlabel('Offset (km)', fontsize=14)
        plt.ylabel(r'|Amplitude (V/m)|', fontsize=14)
        plt.legend()
        plt.show()









1. Full-space VTI model for a finite length, finite strength, rotated bipole
----------------------------------------------------------------------------

1.a Regular VTI case
````````````````````

empymod
```````


.. code-block:: default


    # Survey parameters
    x = (np.arange(1025))*5-2560
    rx = np.repeat([x, ], np.size(x), axis=0)
    ry = rx.transpose()

    # Model parameters
    resh = 1.              # Horizontal resistivity
    aniso = np.sqrt(2.)    # Anisotropy
    resv = resh*aniso**2   # Vertical resistivity
    src = [-50, 50, -30, 30, -320., -280.]  # Source: [x1, x2, y1, y2, z1, z2]
    src_c = np.mean(np.array(src).reshape(3, 2), 1).ravel()  # Center pts of source
    zrec = -400.           # Receiver depth
    freq = 0.77            # Frequency
    strength = np.pi       # Source strength

    # Input for empymod
    model = {
        'src': src,
        'depth': [],
        'res': resh,
        'aniso': aniso,
        'strength': strength,
        'srcpts': 5,
        'freqtime': freq,
        'xdirect': True,  # Use analytical fullspace solution
        'htarg': {'pts_per_dec': -1},
    }










.. code-block:: default


    epm_fs_x = empymod.bipole(rec=[rx.ravel(), ry.ravel(), zrec, 0, 0], verb=3,
                              **model).reshape(np.shape(rx))
    epm_fs_y = empymod.bipole(rec=[rx.ravel(), ry.ravel(), zrec, 90, 0], verb=1,
                              **model).reshape(np.shape(rx))
    epm_fs_z = empymod.bipole(rec=[rx.ravel(), ry.ravel(), zrec, 0, 90], verb=1,
                              **model).reshape(np.shape(rx))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    :: empymod START  ::  v2.0.2

       depth       [m] :  
       res     [Ohm.m] :  1
       aniso       [-] :  1.41421
       epermH      [-] :  1
       epermV      [-] :  1
       mpermH      [-] :  1
       mpermV      [-] :  1

    >  MODEL IS A FULLSPACE; returning analytical frequency-domain solution
       direct field    :  Comp. in frequency domain
       frequency  [Hz] :  0.77
       Hankel          :  DLF (Fast Hankel Transform)
         > Filter      :  Key 201 (2009)
         > DLF type    :  Lagged Convolution
       Loop over       :  Frequencies
       Source(s)       :  1 bipole(s)
         > intpts      :  5
         > length  [m] :  123.288
         > strength[A] :  3.14159
         > x_c     [m] :  0
         > y_c     [m] :  0
         > z_c     [m] :  -300
         > azimuth [째] :  30.9638
         > dip     [째] :  18.9318
       Receiver(s)     :  1050625 dipole(s)
         > x       [m] :  -2560 - 2560 : 1.05062E+06  [min-max; #]
         > y       [m] :  -2560 - 2560 : 1.05062E+06  [min-max; #]
         > z       [m] :  -400
         > azimuth [째] :  0
         > dip     [째] :  0
       Required ab's   :  11 12 13
    * WARNING :: Offsets < 0.001 m are set to 0.001 m!

    :: empymod END; runtime = 0:00:06.755810 :: 

    * WARNING :: Offsets < 0.001 m are set to 0.001 m!
    * WARNING :: Offsets < 0.001 m are set to 0.001 m!




emg3d
`````


.. code-block:: default


    # Get computation domain as a function of frequency (resp., skin depth)
    hx_min, xdomain = emg3d.meshes.get_domain(x0=src_c[0], freq=0.1, min_width=20)
    hz_min, zdomain = emg3d.meshes.get_domain(x0=src_c[2], freq=0.1, min_width=20)

    # Create stretched grid
    nx = 2**7
    hx = emg3d.meshes.get_stretched_h(hx_min, xdomain, nx, src_c[0])
    hy = emg3d.meshes.get_stretched_h(hx_min, xdomain, nx, src_c[1])
    hz = emg3d.meshes.get_stretched_h(hz_min, zdomain, nx, src_c[2])
    pgrid = emg3d.TensorMesh([hx, hy, hz], x0=(xdomain[0], xdomain[0], zdomain[0]))
    pgrid







.. only:: builder_html

    .. raw:: html

        <table>
          <tr>
            <td style='font-weight: bold; font-size: 1.2em; text-align: center;' colspan='3'>TensorMesh</td>
            <td style='font-size: 1.2em; text-align: center;'colspan='4'>2,097,152 cells</td>
          </tr>
          <tr>
            <th></th>
            <th></th>
            <th colspan='2' style='padding: 5px 20px 5px 20px;'>MESH EXTENT</th>
            <th colspan='2' style='padding: 5px 20px 5px 20px;'>CELL WIDTH</th>
            <th style='padding: 5px 20px 5px 20px;'>FACTOR</th>
          </tr>
          <tr>
            <th style='padding: 5px 20px 5px 20px;'>dir</th>
            <th style='padding: 5px 20px 5px 20px;'>nC</th>
            <th style='padding: 5px 20px 5px 20px;'>min</th>
            <th style='padding: 5px 20px 5px 20px;'>max</th>
            <th style='padding: 5px 20px 5px 20px;'>min</th>
            <th style='padding: 5px 20px 5px 20px;'>max</th>
            <th style='padding: 5px 20px 5px 20px;'>max</th>
          </tr>
          <tr>
            <td style='padding: 5px 20px 5px 20px;'>x</td>
            <td style='padding: 5px 20px 5px 20px;'>128</td>
            <td style='padding: 5px 20px 5px 20px;'>-4,358.71</td>
            <td style='padding: 5px 20px 5px 20px;'>4,505.64</td>
            <td style='padding: 5px 20px 5px 20px;'>20.00</td>
            <td style='padding: 5px 20px 5px 20px;'>166.93</td>
            <td style='padding: 5px 20px 5px 20px;'>1.03</td>
          </tr>
          <tr>
            <td style='padding: 5px 20px 5px 20px;'>y</td>
            <td style='padding: 5px 20px 5px 20px;'>128</td>
            <td style='padding: 5px 20px 5px 20px;'>-4,358.71</td>
            <td style='padding: 5px 20px 5px 20px;'>4,505.64</td>
            <td style='padding: 5px 20px 5px 20px;'>20.00</td>
            <td style='padding: 5px 20px 5px 20px;'>166.93</td>
            <td style='padding: 5px 20px 5px 20px;'>1.03</td>
          </tr>
          <tr>
            <td style='padding: 5px 20px 5px 20px;'>z</td>
            <td style='padding: 5px 20px 5px 20px;'>128</td>
            <td style='padding: 5px 20px 5px 20px;'>-4,658.71</td>
            <td style='padding: 5px 20px 5px 20px;'>4,205.64</td>
            <td style='padding: 5px 20px 5px 20px;'>20.00</td>
            <td style='padding: 5px 20px 5px 20px;'>166.93</td>
            <td style='padding: 5px 20px 5px 20px;'>1.03</td>
          </tr>
        </table>

        <br />
        <br />


.. code-block:: default


    # Get the model
    pmodel = emg3d.Model(
            pgrid, property_x=resh, property_z=resv, mapping='Resistivity')

    # Get the source field
    sfield = emg3d.get_source_field(pgrid, src, freq, strength)

    # Compute the electric field
    pfield = emg3d.solve(pgrid, pmodel, sfield, verb=3)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    :: emg3d START :: 11:43:03 :: v0.12.0

       MG-cycle       : 'F'                 sslsolver : False
       semicoarsening : False [0]           tol       : 1e-06
       linerelaxation : False [0]           maxit     : 50
       nu_{i,1,c,2}   : 0, 2, 1, 2          verb      : 3
       Original grid  : 128 x 128 x 128     => 2,097,152 cells
       Coarsest grid  :   2 x   2 x   2     => 8 cells
       Coarsest level :   6 ;   6 ;   6   

       [hh:mm:ss]  rel. error                  [abs. error, last/prev]   l s

           h_
          2h_ \                                        /
          4h_  \                            /\        / 
          8h_   \                  /\      /  \      /  
         16h_    \          /\    /  \    /    \    /   
         32h_     \    /\  /  \  /    \  /      \  /    
         64h_      \/\/  \/    \/      \/        \/     

       [11:43:14]   3.179e-02  after   1 F-cycles   [2.075e-05, 0.032]   0 0
       [11:43:24]   3.147e-03  after   2 F-cycles   [2.054e-06, 0.099]   0 0
       [11:43:33]   4.334e-04  after   3 F-cycles   [2.829e-07, 0.138]   0 0
       [11:43:43]   6.934e-05  after   4 F-cycles   [4.527e-08, 0.160]   0 0
       [11:43:52]   1.362e-05  after   5 F-cycles   [8.889e-09, 0.196]   0 0
       [11:44:02]   4.559e-06  after   6 F-cycles   [2.976e-09, 0.335]   0 0
       [11:44:12]   2.414e-06  after   7 F-cycles   [1.576e-09, 0.530]   0 0
       [11:44:22]   1.474e-06  after   8 F-cycles   [9.621e-10, 0.610]   0 0
       [11:44:32]   9.534e-07  after   9 F-cycles   [6.224e-10, 0.647]   0 0

       > CONVERGED
       > MG cycles        : 9
       > Final rel. error : 9.534e-07

    :: emg3d END   :: 11:44:32 :: runtime = 0:01:28





Plot
````


.. code-block:: default


    e3d_fs_x = emg3d.get_receiver(pgrid, pfield.fx, (rx, ry, zrec))
    plot_result_rel(epm_fs_x, e3d_fs_x, x, r'Diffusive Fullspace $E_x$',
                    vmin=-12, vmax=-6, mode='abs')





.. image:: /gallery/comparisons/images/sphx_glr_1D_VTI_empymod_001.png
    :alt: Diffusive Fullspace $E_x$, (a) |Re(empymod)|, (b) |Re(emg3d)|, (c) Error real part, (d) |Im(empymod)|, (e) |Im(emg3d)|, (f) Error imaginary part
    :class: sphx-glr-single-img






.. code-block:: default


    e3d_fs_y = emg3d.get_receiver(pgrid, pfield.fy, (rx, ry, zrec))
    plot_result_rel(epm_fs_y, e3d_fs_y, x, r'Diffusive Fullspace $E_y$',
                    vmin=-12, vmax=-6, mode='abs')





.. image:: /gallery/comparisons/images/sphx_glr_1D_VTI_empymod_002.png
    :alt: Diffusive Fullspace $E_y$, (a) |Re(empymod)|, (b) |Re(emg3d)|, (c) Error real part, (d) |Im(empymod)|, (e) |Im(emg3d)|, (f) Error imaginary part
    :class: sphx-glr-single-img






.. code-block:: default


    e3d_fs_z = emg3d.get_receiver(pgrid, pfield.fz, (rx, ry, zrec))
    plot_result_rel(epm_fs_z, e3d_fs_z, x, r'Diffusive Fullspace $E_z$',
                    vmin=-12, vmax=-6, mode='abs')





.. image:: /gallery/comparisons/images/sphx_glr_1D_VTI_empymod_003.png
    :alt: Diffusive Fullspace $E_z$, (a) |Re(empymod)|, (b) |Re(emg3d)|, (c) Error real part, (d) |Im(empymod)|, (e) |Im(emg3d)|, (f) Error imaginary part
    :class: sphx-glr-single-img






.. code-block:: default


    plot_lineplot_ex(x, x, e3d_fs_x.real, epm_fs_x.real, pgrid)





.. image:: /gallery/comparisons/images/sphx_glr_1D_VTI_empymod_004.png
    :alt: Inline and crossline $E_x$
    :class: sphx-glr-single-img





1.b Tri-axial anisotropy check
``````````````````````````````

Swap ``x`` and ``z`` in ``emg3d``; compare ``yz``-slice

``empymod`` can handle VTI, but not tri-axial anisotropy. To verify tri-axial
anisotropy in ``emg3d``, we swap the ``x`` and ``z`` axes, and compare the
``xy``-``empymod`` result to the ``zy``-``emg3d`` result.


.. code-block:: default


    # ===> Swap hy and hz; ydomain and zdomain <===
    pgrid = emg3d.TensorMesh([hx, hz, hy], x0=(xdomain[0], zdomain[0], xdomain[0]))

    # ===> Swap y- and z-resistivities <===
    pmodel = emg3d.Model(
            pgrid, property_x=resh, property_y=resv, mapping='Resistivity')

    # ===> Swap src_y and src_z <===
    src_new = [src[0], src[1], src[4], src[5], src[2], src[3]]

    sfield = emg3d.get_source_field(pgrid, src_new, freq, strength)
    pfield = emg3d.solve(pgrid, pmodel, sfield, verb=3)

    # ===> Swap ry and zrec <===
    e3d_fs_x = emg3d.get_receiver(pgrid, pfield.fx, (rx, zrec, ry))
    plot_result_rel(epm_fs_x, e3d_fs_x, x, r'Diffusive Fullspace $E_x$',
                    vmin=-12, vmax=-6, mode='abs')

    # ===> Swap ry and zrec; 'y'->'z' <===
    e3d_fs_y = emg3d.get_receiver(pgrid, pfield.fz, (rx, zrec, ry))
    plot_result_rel(epm_fs_y, e3d_fs_y, x, r'Diffusive Fullspace $E_y$',
                    vmin=-12, vmax=-6, mode='abs')

    # ===> Swap ry and zrec; 'z'->'y' <===
    e3d_fs_z = emg3d.get_receiver(pgrid, pfield.fy, (rx, zrec, ry))
    plot_result_rel(epm_fs_z, e3d_fs_z, x, r'Diffusive Fullspace $E_z$',
                    vmin=-12, vmax=-6, mode='abs')




.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /gallery/comparisons/images/sphx_glr_1D_VTI_empymod_005.png
          :alt: Diffusive Fullspace $E_x$, (a) |Re(empymod)|, (b) |Re(emg3d)|, (c) Error real part, (d) |Im(empymod)|, (e) |Im(emg3d)|, (f) Error imaginary part
          :class: sphx-glr-multi-img

    *

      .. image:: /gallery/comparisons/images/sphx_glr_1D_VTI_empymod_006.png
          :alt: Diffusive Fullspace $E_y$, (a) |Re(empymod)|, (b) |Re(emg3d)|, (c) Error real part, (d) |Im(empymod)|, (e) |Im(emg3d)|, (f) Error imaginary part
          :class: sphx-glr-multi-img

    *

      .. image:: /gallery/comparisons/images/sphx_glr_1D_VTI_empymod_007.png
          :alt: Diffusive Fullspace $E_z$, (a) |Re(empymod)|, (b) |Re(emg3d)|, (c) Error real part, (d) |Im(empymod)|, (e) |Im(emg3d)|, (f) Error imaginary part
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    :: emg3d START :: 11:44:45 :: v0.12.0

       MG-cycle       : 'F'                 sslsolver : False
       semicoarsening : False [0]           tol       : 1e-06
       linerelaxation : False [0]           maxit     : 50
       nu_{i,1,c,2}   : 0, 2, 1, 2          verb      : 3
       Original grid  : 128 x 128 x 128     => 2,097,152 cells
       Coarsest grid  :   2 x   2 x   2     => 8 cells
       Coarsest level :   6 ;   6 ;   6   

       [hh:mm:ss]  rel. error                  [abs. error, last/prev]   l s

           h_
          2h_ \                                        /
          4h_  \                            /\        / 
          8h_   \                  /\      /  \      /  
         16h_    \          /\    /  \    /    \    /   
         32h_     \    /\  /  \  /    \  /      \  /    
         64h_      \/\/  \/    \/      \/        \/     

       [11:44:56]   3.118e-02  after   1 F-cycles   [2.035e-05, 0.031]   0 0
       [11:45:06]   3.130e-03  after   2 F-cycles   [2.043e-06, 0.100]   0 0
       [11:45:16]   4.321e-04  after   3 F-cycles   [2.821e-07, 0.138]   0 0
       [11:45:26]   7.014e-05  after   4 F-cycles   [4.579e-08, 0.162]   0 0
       [11:45:36]   1.509e-05  after   5 F-cycles   [9.850e-09, 0.215]   0 0
       [11:45:45]   5.955e-06  after   6 F-cycles   [3.887e-09, 0.395]   0 0
       [11:45:55]   3.381e-06  after   7 F-cycles   [2.207e-09, 0.568]   0 0
       [11:46:05]   2.119e-06  after   8 F-cycles   [1.383e-09, 0.627]   0 0
       [11:46:15]   1.390e-06  after   9 F-cycles   [9.074e-10, 0.656]   0 0
       [11:46:25]   9.434e-07  after  10 F-cycles   [6.158e-10, 0.679]   0 0

       > CONVERGED
       > MG cycles        : 10
       > Final rel. error : 9.434e-07

    :: emg3d END   :: 11:46:25 :: runtime = 0:01:39





1.c Tri-axial anisotropy check
``````````````````````````````

Swap ``y`` and ``z`` in ``emg3d``; compare ``xz``-slice

``empymod`` can handle VTI, but not tri-axial anisotropy. To verify tri-axial
anisotropy in ``emg3d``, we swap the ``y`` and ``z`` axes, and compare the
``xy``-``empymod`` result to the ``xz``-``emg3d`` result.


.. code-block:: default


    # ===> Swap hx and hz; xdomain and zdomain <===
    pgrid = emg3d.TensorMesh([hz, hy, hx], x0=(zdomain[0], xdomain[0], xdomain[0]))

    # ===> Swap x- and z-resistivities <===
    pmodel = emg3d.Model(
            pgrid, property_x=resv, property_y=resh, property_z=resh,
            mapping='Resistivity')

    # ===> Swap src_x and src_z <===
    src_new = [src[4], src[5], src[2], src[3], src[0], src[1]]

    sfield = emg3d.get_source_field(pgrid, src_new, freq, strength)
    pfield = emg3d.solve(pgrid, pmodel, sfield, verb=3)

    # ===> Swap rx and zrec; 'x'->'z' <===
    e3d_fs_x = emg3d.get_receiver(pgrid, pfield.fz, (zrec, ry, rx))
    plot_result_rel(epm_fs_x, e3d_fs_x, x, r'Diffusive Fullspace $E_x$',
                    vmin=-12, vmax=-6, mode='abs')

    # ===> Swap rx and zrec <===
    e3d_fs_y = emg3d.get_receiver(pgrid, pfield.fy, (zrec, ry, rx))
    plot_result_rel(epm_fs_y, e3d_fs_y, x, r'Diffusive Fullspace $E_y$',
                    vmin=-12, vmax=-6, mode='abs')

    # ===> Swap rx and zrec; 'z'->'x' <===
    e3d_fs_z = emg3d.get_receiver(pgrid, pfield.fx, (zrec, ry, rx))
    plot_result_rel(epm_fs_z, e3d_fs_z, x, r'Diffusive Fullspace $E_z$',
                    vmin=-12, vmax=-6, mode='abs')





.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /gallery/comparisons/images/sphx_glr_1D_VTI_empymod_008.png
          :alt: Diffusive Fullspace $E_x$, (a) |Re(empymod)|, (b) |Re(emg3d)|, (c) Error real part, (d) |Im(empymod)|, (e) |Im(emg3d)|, (f) Error imaginary part
          :class: sphx-glr-multi-img

    *

      .. image:: /gallery/comparisons/images/sphx_glr_1D_VTI_empymod_009.png
          :alt: Diffusive Fullspace $E_y$, (a) |Re(empymod)|, (b) |Re(emg3d)|, (c) Error real part, (d) |Im(empymod)|, (e) |Im(emg3d)|, (f) Error imaginary part
          :class: sphx-glr-multi-img

    *

      .. image:: /gallery/comparisons/images/sphx_glr_1D_VTI_empymod_010.png
          :alt: Diffusive Fullspace $E_z$, (a) |Re(empymod)|, (b) |Re(emg3d)|, (c) Error real part, (d) |Im(empymod)|, (e) |Im(emg3d)|, (f) Error imaginary part
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    :: emg3d START :: 11:46:38 :: v0.12.0

       MG-cycle       : 'F'                 sslsolver : False
       semicoarsening : False [0]           tol       : 1e-06
       linerelaxation : False [0]           maxit     : 50
       nu_{i,1,c,2}   : 0, 2, 1, 2          verb      : 3
       Original grid  : 128 x 128 x 128     => 2,097,152 cells
       Coarsest grid  :   2 x   2 x   2     => 8 cells
       Coarsest level :   6 ;   6 ;   6   

       [hh:mm:ss]  rel. error                  [abs. error, last/prev]   l s

           h_
          2h_ \                                        /
          4h_  \                            /\        / 
          8h_   \                  /\      /  \      /  
         16h_    \          /\    /  \    /    \    /   
         32h_     \    /\  /  \  /    \  /      \  /    
         64h_      \/\/  \/    \/      \/        \/     

       [11:46:48]   2.666e-02  after   1 F-cycles   [1.741e-05, 0.027]   0 0
       [11:46:58]   3.045e-03  after   2 F-cycles   [1.988e-06, 0.114]   0 0
       [11:47:07]   4.339e-04  after   3 F-cycles   [2.832e-07, 0.143]   0 0
       [11:47:17]   7.010e-05  after   4 F-cycles   [4.576e-08, 0.162]   0 0
       [11:47:27]   1.487e-05  after   5 F-cycles   [9.706e-09, 0.212]   0 0
       [11:47:37]   5.914e-06  after   6 F-cycles   [3.861e-09, 0.398]   0 0
       [11:47:46]   3.427e-06  after   7 F-cycles   [2.237e-09, 0.580]   0 0
       [11:47:58]   2.182e-06  after   8 F-cycles   [1.425e-09, 0.637]   0 0
       [11:48:08]   1.448e-06  after   9 F-cycles   [9.453e-10, 0.664]   0 0
       [11:48:17]   9.913e-07  after  10 F-cycles   [6.472e-10, 0.685]   0 0

       > CONVERGED
       > MG cycles        : 10
       > Final rel. error : 9.913e-07

    :: emg3d END   :: 11:48:17 :: runtime = 0:01:40





2. Layered model for a deep water model with a point dipole source
------------------------------------------------------------------

empymod
```````


.. code-block:: default


    # Survey parameters
    x = (np.arange(1025))*5-2560
    rx = np.repeat([x, ], np.size(x), axis=0)
    ry = rx.transpose()

    # Model parameters
    resh = [1, 50, 1, 0.3, 1e12]      # Horizontal resistivity
    aniso = np.sqrt([2, 2, 2, 1, 1])  # Anisotropy
    resv = resh*aniso**2              # Vertical resistivity
    src = [0, 0, -900, 0, 0]          # Source: [x, y, z, azimuth, dip]
    zrec = -950.                      # Receiver depth
    freq = 1                          # Frequency
    depth = np.array([-2200, -2000, -1000, 0])  # Layer boundaries

    model = {
        'src': src,
        'depth': depth,
        'res': resh,
        'aniso': aniso,
        'freqtime': freq,
        'htarg': {'pts_per_dec': -1},
    }










.. code-block:: default


    epm_deep_x = empymod.bipole(rec=[rx.ravel(), ry.ravel(), zrec, 0, 0],
                                verb=3, **model).reshape(np.shape(rx))
    epm_deep_y = empymod.bipole(rec=[rx.ravel(), ry.ravel(), zrec, 90, 0],
                                verb=1, **model).reshape(np.shape(rx))
    epm_deep_z = empymod.bipole(rec=[rx.ravel(), ry.ravel(), zrec, 0, 90],
                                verb=1, **model).reshape(np.shape(rx))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    :: empymod START  ::  v2.0.2

       depth       [m] :  -2200 -2000 -1000 0
       res     [Ohm.m] :  1 50 1 0.3 1E+12
       aniso       [-] :  1.41421 1.41421 1.41421 1 1
       epermH      [-] :  1 1 1 1 1
       epermV      [-] :  1 1 1 1 1
       mpermH      [-] :  1 1 1 1 1
       mpermV      [-] :  1 1 1 1 1
       direct field    :  Comp. in wavenumber domain
       frequency  [Hz] :  1
       Hankel          :  DLF (Fast Hankel Transform)
         > Filter      :  Key 201 (2009)
         > DLF type    :  Lagged Convolution
       Loop over       :  Frequencies
       Source(s)       :  1 dipole(s)
         > x       [m] :  0
         > y       [m] :  0
         > z       [m] :  -900
         > azimuth [째] :  0
         > dip     [째] :  0
       Receiver(s)     :  1050625 dipole(s)
         > x       [m] :  -2560 - 2560 : 1.05062E+06  [min-max; #]
         > y       [m] :  -2560 - 2560 : 1.05062E+06  [min-max; #]
         > z       [m] :  -950
         > azimuth [째] :  0
         > dip     [째] :  0
       Required ab's   :  11
    * WARNING :: Offsets < 0.001 m are set to 0.001 m!

    :: empymod END; runtime = 0:00:00.655870 :: 1 kernel call(s)

    * WARNING :: Offsets < 0.001 m are set to 0.001 m!
    * WARNING :: Offsets < 0.001 m are set to 0.001 m!




emg3d
`````


.. code-block:: default



    # Get computation domain as a function of frequency (resp., skin depth)
    hx_min, xdomain = emg3d.meshes.get_domain(
            x0=src[0], freq=0.1, min_width=20, fact_neg=10)
    hz_min, zdomain = emg3d.meshes.get_domain(
            x0=src[2], freq=0.1, min_width=20, fact_pos=10)

    # Create stretched grid
    nx = 2**7
    hx = emg3d.meshes.get_stretched_h(hx_min, xdomain, nx, src[0])
    hy = emg3d.meshes.get_stretched_h(hx_min, xdomain, nx, src[1])
    hz = emg3d.meshes.get_stretched_h(hz_min, zdomain, nx*2, x0=depth[0], x1=0)
    pgrid = emg3d.TensorMesh([hx, hy, hz], x0=(xdomain[0], xdomain[0], zdomain[0]))
    pgrid







.. only:: builder_html

    .. raw:: html

        <table>
          <tr>
            <td style='font-weight: bold; font-size: 1.2em; text-align: center;' colspan='3'>TensorMesh</td>
            <td style='font-size: 1.2em; text-align: center;'colspan='4'>4,194,304 cells</td>
          </tr>
          <tr>
            <th></th>
            <th></th>
            <th colspan='2' style='padding: 5px 20px 5px 20px;'>MESH EXTENT</th>
            <th colspan='2' style='padding: 5px 20px 5px 20px;'>CELL WIDTH</th>
            <th style='padding: 5px 20px 5px 20px;'>FACTOR</th>
          </tr>
          <tr>
            <th style='padding: 5px 20px 5px 20px;'>dir</th>
            <th style='padding: 5px 20px 5px 20px;'>nC</th>
            <th style='padding: 5px 20px 5px 20px;'>min</th>
            <th style='padding: 5px 20px 5px 20px;'>max</th>
            <th style='padding: 5px 20px 5px 20px;'>min</th>
            <th style='padding: 5px 20px 5px 20px;'>max</th>
            <th style='padding: 5px 20px 5px 20px;'>max</th>
          </tr>
          <tr>
            <td style='padding: 5px 20px 5px 20px;'>x</td>
            <td style='padding: 5px 20px 5px 20px;'>128</td>
            <td style='padding: 5px 20px 5px 20px;'>-8,717.41</td>
            <td style='padding: 5px 20px 5px 20px;'>9,154.10</td>
            <td style='padding: 5px 20px 5px 20px;'>20.00</td>
            <td style='padding: 5px 20px 5px 20px;'>456.68</td>
            <td style='padding: 5px 20px 5px 20px;'>1.05</td>
          </tr>
          <tr>
            <td style='padding: 5px 20px 5px 20px;'>y</td>
            <td style='padding: 5px 20px 5px 20px;'>128</td>
            <td style='padding: 5px 20px 5px 20px;'>-8,717.41</td>
            <td style='padding: 5px 20px 5px 20px;'>9,154.10</td>
            <td style='padding: 5px 20px 5px 20px;'>20.00</td>
            <td style='padding: 5px 20px 5px 20px;'>456.68</td>
            <td style='padding: 5px 20px 5px 20px;'>1.05</td>
          </tr>
          <tr>
            <td style='padding: 5px 20px 5px 20px;'>z</td>
            <td style='padding: 5px 20px 5px 20px;'>256</td>
            <td style='padding: 5px 20px 5px 20px;'>-5,258.71</td>
            <td style='padding: 5px 20px 5px 20px;'>7,568.16</td>
            <td style='padding: 5px 20px 5px 20px;'>20.00</td>
            <td style='padding: 5px 20px 5px 20px;'>229.22</td>
            <td style='padding: 5px 20px 5px 20px;'>1.03</td>
          </tr>
        </table>

        <br />
        <br />


.. code-block:: default


    # Create the model: horizontal resistivity
    res_x_full = resh[0]*np.ones(pgrid.nC)  # Background
    res_x_full[pgrid.gridCC[:, 2] >= depth[0]] = resh[1]  # Target
    res_x_full[pgrid.gridCC[:, 2] >= depth[1]] = resh[2]  # Overburden
    res_x_full[pgrid.gridCC[:, 2] >= depth[2]] = resh[3]  # Water
    res_x_full[pgrid.gridCC[:, 2] >= depth[3]] = resh[4]  # Air

    # Create the model: vertical resistivity
    res_z_full = resv[0]*np.ones(pgrid.nC)  # Background
    res_z_full[pgrid.gridCC[:, 2] >= depth[0]] = resv[1]
    res_z_full[pgrid.gridCC[:, 2] >= depth[1]] = resv[2]
    res_z_full[pgrid.gridCC[:, 2] >= depth[2]] = resv[3]
    res_z_full[pgrid.gridCC[:, 2] >= depth[3]] = resv[4]

    # Get the model
    pmodel = emg3d.Model(
            pgrid, property_x=res_x_full, property_z=res_z_full,
            mapping='Resistivity')

    # Plot it
    pgrid.plot_3d_slicer(pmodel.property_x, zslice=-2000, clim=[0.3, 50],
                         zlim=(-5000, 50), pcolor_opts={'norm': LogNorm()})





.. image:: /gallery/comparisons/images/sphx_glr_1D_VTI_empymod_011.png
    :alt: 1D VTI empymod
    :class: sphx-glr-single-img






.. code-block:: default


    # Get the source field
    sfield = emg3d.get_source_field(pgrid, src, freq, 0)

    # Compute the electric field
    pfield = emg3d.solve(pgrid, pmodel, sfield, verb=3)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    :: emg3d START :: 11:48:34 :: v0.12.0

       MG-cycle       : 'F'                 sslsolver : False
       semicoarsening : False [0]           tol       : 1e-06
       linerelaxation : False [0]           maxit     : 50
       nu_{i,1,c,2}   : 0, 2, 1, 2          verb      : 3
       Original grid  : 128 x 128 x 256     => 4,194,304 cells
       Coarsest grid  :   2 x   2 x   2     => 8 cells
       Coarsest level :   6 ;   6 ;   7   

       [hh:mm:ss]  rel. error                  [abs. error, last/prev]   l s

           h_
          2h_ \                                                      /
          4h_  \                                        /\          / 
          8h_   \                            /\        /  \        /  
         16h_    \                  /\      /  \      /    \      /   
         32h_     \          /\    /  \    /    \    /      \    /    
         64h_      \    /\  /  \  /    \  /      \  /        \  /     
        128h_       \/\/  \/    \/      \/        \/          \/      

       [11:48:55]   2.632e-02  after   1 F-cycles   [1.470e-07, 0.026]   0 0
       [11:49:14]   2.086e-03  after   2 F-cycles   [1.165e-08, 0.079]   0 0
       [11:49:35]   2.056e-04  after   3 F-cycles   [1.148e-09, 0.099]   0 0
       [11:49:54]   3.289e-05  after   4 F-cycles   [1.837e-10, 0.160]   0 0
       [11:50:16]   1.306e-05  after   5 F-cycles   [7.292e-11, 0.397]   0 0
       [11:50:36]   7.546e-06  after   6 F-cycles   [4.214e-11, 0.578]   0 0
       [11:50:57]   4.917e-06  after   7 F-cycles   [2.746e-11, 0.652]   0 0
       [11:51:18]   3.435e-06  after   8 F-cycles   [1.918e-11, 0.699]   0 0
       [11:51:37]   2.525e-06  after   9 F-cycles   [1.410e-11, 0.735]   0 0
       [11:51:57]   1.932e-06  after  10 F-cycles   [1.079e-11, 0.765]   0 0
       [11:52:16]   1.528e-06  after  11 F-cycles   [8.531e-12, 0.791]   0 0
       [11:52:35]   1.240e-06  after  12 F-cycles   [6.925e-12, 0.812]   0 0
       [11:52:54]   1.028e-06  after  13 F-cycles   [5.744e-12, 0.829]   0 0
       [11:53:14]   8.682e-07  after  14 F-cycles   [4.849e-12, 0.844]   0 0

       > CONVERGED
       > MG cycles        : 14
       > Final rel. error : 8.682e-07

    :: emg3d END   :: 11:53:14 :: runtime = 0:04:40





Plot
````


.. code-block:: default


    e3d_deep_x = emg3d.get_receiver(pgrid, pfield.fx, (rx, ry, zrec))
    plot_result_rel(epm_deep_x, e3d_deep_x, x, r'Deep water point dipole $E_x$',
                    vmin=-14, vmax=-8, mode='abs')





.. image:: /gallery/comparisons/images/sphx_glr_1D_VTI_empymod_012.png
    :alt: Deep water point dipole $E_x$, (a) |Re(empymod)|, (b) |Re(emg3d)|, (c) Error real part, (d) |Im(empymod)|, (e) |Im(emg3d)|, (f) Error imaginary part
    :class: sphx-glr-single-img






.. code-block:: default


    e3d_deep_y = emg3d.get_receiver(pgrid, pfield.fy, (rx, ry, zrec))
    plot_result_rel(epm_deep_y, e3d_deep_y, x, r'Deep water point dipole $E_y$',
                    vmin=-14, vmax=-8, mode='abs')





.. image:: /gallery/comparisons/images/sphx_glr_1D_VTI_empymod_013.png
    :alt: Deep water point dipole $E_y$, (a) |Re(empymod)|, (b) |Re(emg3d)|, (c) Error real part, (d) |Im(empymod)|, (e) |Im(emg3d)|, (f) Error imaginary part
    :class: sphx-glr-single-img






.. code-block:: default


    e3d_deep_z = emg3d.get_receiver(pgrid, pfield.fz, (rx, ry, zrec))
    plot_result_rel(epm_deep_z, e3d_deep_z, x, r'Deep water point dipole $E_z$',
                    vmin=-14, vmax=-8, mode='abs')





.. image:: /gallery/comparisons/images/sphx_glr_1D_VTI_empymod_014.png
    :alt: Deep water point dipole $E_z$, (a) |Re(empymod)|, (b) |Re(emg3d)|, (c) Error real part, (d) |Im(empymod)|, (e) |Im(emg3d)|, (f) Error imaginary part
    :class: sphx-glr-single-img






.. code-block:: default


    plot_lineplot_ex(x, x, e3d_deep_x.real, epm_deep_x.real, pgrid)





.. image:: /gallery/comparisons/images/sphx_glr_1D_VTI_empymod_015.png
    :alt: Inline and crossline $E_x$
    :class: sphx-glr-single-img






.. code-block:: default


    emg3d.Report()





.. only:: builder_html

    .. raw:: html

        <table style='border: 3px solid #ddd;'>
          <tr>
             <td style='text-align: center; font-weight: bold; font-size: 1.2em; border: 2px solid #fff;' colspan='6'>Thu Jul 30 11:53:28 2020 CEST</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>OS</td>
            <td style='text-align: left; border: 2px solid #fff;'>Linux</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>CPU(s)</td>
            <td style='text-align: left; border: 2px solid #fff;'>4</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>Machine</td>
            <td style='text-align: left; border: 2px solid #fff;'>x86_64</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>Architecture</td>
            <td style='text-align: left; border: 2px solid #fff;'>64bit</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>RAM</td>
            <td style='text-align: left; border: 2px solid #fff;'>15.5 GB</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>Environment</td>
            <td style='text-align: left; border: 2px solid #fff;'>Python</td>
          </tr>
          <tr>
             <td style='text-align: center; border: 2px solid #fff;' colspan='6'>Python 3.8.3 (default, Jul  2 2020, 16:21:59) 
        [GCC 7.3.0]</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>numpy</td>
            <td style='text-align: left; border: 2px solid #fff;'>1.18.5</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>scipy</td>
            <td style='text-align: left; border: 2px solid #fff;'>1.5.0</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>numba</td>
            <td style='text-align: left; border: 2px solid #fff;'>0.50.1</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>emg3d</td>
            <td style='text-align: left; border: 2px solid #fff;'>0.12.0</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>empymod</td>
            <td style='text-align: left; border: 2px solid #fff;'>2.0.2</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>xarray</td>
            <td style='text-align: left; border: 2px solid #fff;'>0.16.0</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>discretize</td>
            <td style='text-align: left; border: 2px solid #fff;'>0.4.15</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>h5py</td>
            <td style='text-align: left; border: 2px solid #fff;'>2.10.0</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>matplotlib</td>
            <td style='text-align: left; border: 2px solid #fff;'>3.2.2</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>IPython</td>
            <td style='text-align: left; border: 2px solid #fff;'>7.16.1</td>
            <td style= border: 2px solid #fff;'></td>
            <td style= border: 2px solid #fff;'></td>
            <td style= border: 2px solid #fff;'></td>
            <td style= border: 2px solid #fff;'></td>
          </tr>
          <tr>
             <td style='text-align: center; background-color: #ddd;border: 2px solid #fff;' colspan='6'>Intel(R) Math Kernel Library Version 2020.0.1 Product Build 20200208 for Intel(R) 64 architecture applications</td>
          </tr>
        </table>
        <br />
        <br />


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 10 minutes  43.123 seconds)

**Estimated memory usage:**  2639 MB


.. _sphx_glr_download_gallery_comparisons_1D_VTI_empymod.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: 1D_VTI_empymod.py <1D_VTI_empymod.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: 1D_VTI_empymod.ipynb <1D_VTI_empymod.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
