.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_gallery_magnetics_magnetic_field.py>`     to download the full example code
    .. rst-class:: sphx-glr-example-title

    .. _sphx_glr_gallery_magnetics_magnetic_field.py:


1. Magnetic field due to an el. source
======================================

The solver ``emg3d`` returns the electric field in x-, y-, and z-direction.
Using Farady's law of induction we can obtain the magnetic field from it.
Faraday's law of induction in the frequency domain can be written as, in its
differential form,

.. math::
    :label: faraday

    \nabla \times \mathbf{E} = \rm{i}\omega \mathbf{B} =
    \rm{i}\omega\mu\mathbf{H}\, .

We do exactly this in this example, for a rotated finite length bipole in a
homogeneous VTI fullspace, and compare it to the semi-analytical solution of
``empymod``. (The code ``empymod`` is an open-source code which can model CSEM
responses for a layered medium including VTI electrical anisotropy, see
`empymod.github.io <https://empymod.github.io>`_.)

This is an adapted version of
:ref:`sphx_glr_gallery_comparisons_1D_VTI_empymod.py`. Consult that example to
see the result for the electric field.


.. code-block:: default

    import emg3d
    import empymod
    import numpy as np
    import matplotlib.pyplot as plt
    from scipy import interpolate as sint
    from matplotlib.colors import SymLogNorm
    plt.style.use('ggplot')










.. code-block:: default

    def plot_data_rel(ax, name, data, x, vmin=-15., vmax=-7., mode="log"):
        """Plot function."""

        ax.set_title(name)
        ax.set_xlim(min(x)/1000, max(x)/1000)
        ax.set_ylim(min(x)/1000, max(x)/1000)
        ax.axis("equal")

        if isinstance(mode, str):
            if mode == "abs":
                cf = ax.pcolormesh(
                        x/1000, x/1000, np.log10(np.abs(data)), linewidth=0,
                        rasterized=True, cmap="viridis", vmin=vmin, vmax=vmax)
            else:
                cf = ax.pcolormesh(
                        x/1000, x/1000, data, linewidth=0, rasterized=True,
                        cmap="PuOr_r",
                        norm=SymLogNorm(linthresh=10**vmin,
                                        vmin=-10**vmax, vmax=10**vmax))
        else:
            cf = ax.pcolormesh(
                    x/1000, x/1000, np.log10(data), vmin=vmin, vmax=vmax,
                    linewidth=0, rasterized=True,
                    cmap=plt.cm.get_cmap("RdBu_r", 8))

        return cf










.. code-block:: default

    def plot_result_rel(depm, de3d, x, title, vmin=-15., vmax=-7., mode="log"):
        fig, axs = plt.subplots(figsize=(18, 10), nrows=2, ncols=3)

        if mode == "log":
            case = ""
        else:
            case = "|"

        # Plot Re(data)
        cf0 = plot_data_rel(axs[0, 0], r"(a) "+case+"Re(empymod)"+case,
                            depm.real, x, vmin, vmax, mode)
        plot_data_rel(axs[0, 1], r"(b) "+case+"Re(emg3d)"+case,
                      de3d.real, x, vmin, vmax, mode)
        cf2 = plot_data_rel(axs[0, 2], r"(c) Error real part",
                            np.abs((depm.real-de3d.real)/depm.real)*100, x,
                            vmin=-2, vmax=2, mode=True)

        # Plot Im(data)
        plot_data_rel(axs[1, 0], r"(d) "+case+"Im(empymod)"+case,
                      depm.imag, x, vmin, vmax, mode)
        plot_data_rel(axs[1, 1], r"(e) "+case+"Im(emg3d)"+case,
                      de3d.imag, x, vmin, vmax, mode)
        plot_data_rel(axs[1, 2], r"(f) Error imaginary part",
                      np.abs((depm.imag-de3d.imag)/depm.imag)*100,
                      x, vmin=-2, vmax=2, mode=True)

        # Colorbars
        fig.colorbar(cf0, ax=axs[0, :], label=r"$\log_{10}$ Amplitude (A/m)")
        cbar = fig.colorbar(cf2, ax=axs[1, :], label=r"Relative Error")
        cbar.set_ticks([-2, -1, 0, 1, 2])
        cbar.ax.set_yticklabels([r"$0.01\,\%$", r"$0.1\,\%$", r"$1\,\%$",
                                 r"$10\,\%$", r"$100\,\%$"])

        # Axis label
        fig.text(0.4, 0.05, "Inline Offset (km)", fontsize=14)
        fig.text(0.08, 0.6, "Crossline Offset (km)", rotation=90, fontsize=14)

        # Title
        fig.suptitle(title, y=1, fontsize=20)
        plt.show()










.. code-block:: default

    def plot_lineplot_ex(x, y, data, epm_fs, grid):
        xi = x.size//2
        yi = y.size//2

        fn = sint.interp1d(x, data[:, xi], bounds_error=False)
        x1 = fn(grid.vectorNx)

        fn = sint.interp1d(y, data[yi, :], bounds_error=False)
        y1 = fn(grid.vectorNx)

        plt.figure(figsize=(15, 8))

        plt.plot(x/1e3, np.abs(epm_fs[:, xi]), 'C0', lw=3, label='Inline empymod')
        plt.plot(x/1e3, np.abs(data[:, xi]), 'k--', label='Inline emg3d')
        plt.plot(grid.vectorNx/1e3, np.abs(x1), 'k*')

        plt.plot(y/1e3, np.abs(epm_fs[yi, :]), 'C1', lw=3,
                 label='Crossline empymod')
        plt.plot(y/1e3, np.abs(data[yi, :]), 'k:', label='Crossline emg3d')
        plt.plot(grid.vectorNx/1e3, np.abs(y1), 'k*', label='Grid points emg3d')

        plt.yscale('log')
        plt.title(r'Inline and crossline $H_x$', fontsize=20)
        plt.xlabel('Offset (km)', fontsize=14)
        plt.ylabel(r'|Amplitude (A/m)|', fontsize=14)
        plt.legend()
        plt.show()









Full-space model for a finite length, finite strength, rotated bipole
---------------------------------------------------------------------

empymod
```````


.. code-block:: default


    # Survey parameters
    x = (np.arange(1025))*5-2560
    rx = np.repeat([x, ], np.size(x), axis=0)
    ry = rx.transpose()

    # Model parameters
    resh = 1.              # Horizontal resistivity
    aniso = np.sqrt(2.)    # Anisotropy
    resv = resh*aniso**2   # Vertical resistivity
    src = [-50, 50, -30, 30, -320., -280.]  # Source: [x1, x2, y1, y2, z1, z2]
    src_c = np.mean(np.array(src).reshape(3, 2), 1).ravel()  # Center pts of source
    zrec = -400.           # Receiver depth
    freq = 0.77            # Frequency
    strength = np.pi       # Source strength

    # Input for empymod
    model = {
        'src': src,
        'depth': [],
        'res': resh,
        'aniso': aniso,
        'strength': strength,
        'srcpts': 5,
        'freqtime': freq,
        'htarg': {'pts_per_dec': -1},
    }









.. code-block:: default

    epm_fs_hx = -empymod.bipole(rec=[rx.ravel(), ry.ravel(), zrec, 0, 0],
                                mrec=True, verb=3, **model).reshape(np.shape(rx))
    epm_fs_hy = -empymod.bipole(rec=[rx.ravel(), ry.ravel(), zrec, 90, 0],
                                mrec=True, verb=1, **model).reshape(np.shape(rx))
    epm_fs_hz = -empymod.bipole(rec=[rx.ravel(), ry.ravel(), zrec, 0, 90],
                                mrec=True, verb=1, **model).reshape(np.shape(rx))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    :: empymod START  ::  v2.0.2

       depth       [m] :  
       res     [Ohm.m] :  1
       aniso       [-] :  1.41421
       epermH      [-] :  1
       epermV      [-] :  1
       mpermH      [-] :  1
       mpermV      [-] :  1

    >  MODEL IS A FULLSPACE
       direct field    :  Comp. in wavenumber domain
       frequency  [Hz] :  0.77
       Hankel          :  DLF (Fast Hankel Transform)
         > Filter      :  Key 201 (2009)
         > DLF type    :  Lagged Convolution
       Loop over       :  Frequencies
       Source(s)       :  1 bipole(s)
         > intpts      :  5
         > length  [m] :  123.288
         > strength[A] :  3.14159
         > x_c     [m] :  0
         > y_c     [m] :  0
         > z_c     [m] :  -300
         > azimuth [째] :  30.9638
         > dip     [째] :  18.9318
       Receiver(s)     :  1050625 dipole(s)
         > x       [m] :  -2560 - 2560 : 1.05062E+06  [min-max; #]
         > y       [m] :  -2560 - 2560 : 1.05062E+06  [min-max; #]
         > z       [m] :  -400
         > azimuth [째] :  0
         > dip     [째] :  0
       Required ab's   :  14 24 34
    * WARNING :: Offsets < 0.001 m are set to 0.001 m!

    :: empymod END; runtime = 0:00:04.277174 :: 15 kernel call(s)

    * WARNING :: Offsets < 0.001 m are set to 0.001 m!
    * WARNING :: Offsets < 0.001 m are set to 0.001 m!




emg3d
`````


.. code-block:: default


    # Get computation domain as a function of frequency (resp., skin depth)
    hx_min, xdomain = emg3d.meshes.get_domain(x0=src[0], freq=0.1, min_width=20)
    hz_min, zdomain = emg3d.meshes.get_domain(x0=src[2], freq=0.1, min_width=20)

    # Create stretched grid
    nx = 2**7
    hx = emg3d.meshes.get_stretched_h(hx_min, xdomain, nx, src_c[0])
    hy = emg3d.meshes.get_stretched_h(hx_min, xdomain, nx, src_c[1])
    hz = emg3d.meshes.get_stretched_h(hz_min, zdomain, nx, src_c[2])
    pgrid = emg3d.TensorMesh([hx, hy, hz], x0=(xdomain[0], xdomain[0], zdomain[0]))
    pgrid






.. only:: builder_html

    .. raw:: html

        <table>
          <tr>
            <td style='font-weight: bold; font-size: 1.2em; text-align: center;' colspan='3'>TensorMesh</td>
            <td style='font-size: 1.2em; text-align: center;'colspan='4'>2,097,152 cells</td>
          </tr>
          <tr>
            <th></th>
            <th></th>
            <th colspan='2' style='padding: 5px 20px 5px 20px;'>MESH EXTENT</th>
            <th colspan='2' style='padding: 5px 20px 5px 20px;'>CELL WIDTH</th>
            <th style='padding: 5px 20px 5px 20px;'>FACTOR</th>
          </tr>
          <tr>
            <th style='padding: 5px 20px 5px 20px;'>dir</th>
            <th style='padding: 5px 20px 5px 20px;'>nC</th>
            <th style='padding: 5px 20px 5px 20px;'>min</th>
            <th style='padding: 5px 20px 5px 20px;'>max</th>
            <th style='padding: 5px 20px 5px 20px;'>min</th>
            <th style='padding: 5px 20px 5px 20px;'>max</th>
            <th style='padding: 5px 20px 5px 20px;'>max</th>
          </tr>
          <tr>
            <td style='padding: 5px 20px 5px 20px;'>x</td>
            <td style='padding: 5px 20px 5px 20px;'>128</td>
            <td style='padding: 5px 20px 5px 20px;'>-4,408.71</td>
            <td style='padding: 5px 20px 5px 20px;'>4,228.19</td>
            <td style='padding: 5px 20px 5px 20px;'>20.00</td>
            <td style='padding: 5px 20px 5px 20px;'>160.52</td>
            <td style='padding: 5px 20px 5px 20px;'>1.03</td>
          </tr>
          <tr>
            <td style='padding: 5px 20px 5px 20px;'>y</td>
            <td style='padding: 5px 20px 5px 20px;'>128</td>
            <td style='padding: 5px 20px 5px 20px;'>-4,408.71</td>
            <td style='padding: 5px 20px 5px 20px;'>4,228.19</td>
            <td style='padding: 5px 20px 5px 20px;'>20.00</td>
            <td style='padding: 5px 20px 5px 20px;'>160.52</td>
            <td style='padding: 5px 20px 5px 20px;'>1.03</td>
          </tr>
          <tr>
            <td style='padding: 5px 20px 5px 20px;'>z</td>
            <td style='padding: 5px 20px 5px 20px;'>128</td>
            <td style='padding: 5px 20px 5px 20px;'>-4,388.71</td>
            <td style='padding: 5px 20px 5px 20px;'>4,249.67</td>
            <td style='padding: 5px 20px 5px 20px;'>20.00</td>
            <td style='padding: 5px 20px 5px 20px;'>165.56</td>
            <td style='padding: 5px 20px 5px 20px;'>1.03</td>
          </tr>
        </table>

        <br />
        <br />


.. code-block:: default


    # Get the model
    pmodel = emg3d.Model(pgrid, property_x=resh, property_z=resv,
                         mapping='Resistivity')

    # Get the source field
    sfield = emg3d.get_source_field(pgrid, src, freq, strength)

    # Compute the electric field
    pfield = emg3d.solve(pgrid, pmodel, sfield, verb=3)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    :: emg3d START :: 22:38:03 :: v0.12.0

       MG-cycle       : 'F'                 sslsolver : False
       semicoarsening : False [0]           tol       : 1e-06
       linerelaxation : False [0]           maxit     : 50
       nu_{i,1,c,2}   : 0, 2, 1, 2          verb      : 3
       Original grid  : 128 x 128 x 128     => 2,097,152 cells
       Coarsest grid  :   2 x   2 x   2     => 8 cells
       Coarsest level :   6 ;   6 ;   6   

       [hh:mm:ss]  rel. error                  [abs. error, last/prev]   l s

           h_
          2h_ \                                        /
          4h_  \                            /\        / 
          8h_   \                  /\      /  \      /  
         16h_    \          /\    /  \    /    \    /   
         32h_     \    /\  /  \  /    \  /      \  /    
         64h_      \/\/  \/    \/      \/        \/     

       [22:38:13]   2.861e-02  after   1 F-cycles   [1.867e-05, 0.029]   0 0
       [22:38:22]   2.289e-03  after   2 F-cycles   [1.494e-06, 0.080]   0 0
       [22:38:32]   2.686e-04  after   3 F-cycles   [1.753e-07, 0.117]   0 0
       [22:38:41]   4.096e-05  after   4 F-cycles   [2.673e-08, 0.152]   0 0
       [22:38:50]   9.383e-06  after   5 F-cycles   [6.124e-09, 0.229]   0 0
       [22:39:00]   3.895e-06  after   6 F-cycles   [2.542e-09, 0.415]   0 0
       [22:39:10]   2.160e-06  after   7 F-cycles   [1.410e-09, 0.555]   0 0
       [22:39:19]   1.318e-06  after   8 F-cycles   [8.603e-10, 0.610]   0 0
       [22:39:28]   8.487e-07  after   9 F-cycles   [5.539e-10, 0.644]   0 0

       > CONVERGED
       > MG cycles        : 9
       > Final rel. error : 8.487e-07

    :: emg3d END   :: 22:39:28 :: runtime = 0:01:25





Compute magnetic field :math:`H` from the electric field
--------------------------------------------------------


.. code-block:: default

    hfield = emg3d.get_h_field(pgrid, pmodel, pfield)








Plot
````


.. code-block:: default

    e3d_fs_hx = emg3d.get_receiver(pgrid, hfield.fx, (rx, ry, zrec))
    plot_result_rel(epm_fs_hx, e3d_fs_hx, x, r'Diffusive Fullspace $H_x$',
                    vmin=-8, vmax=-4, mode='abs')




.. image:: /gallery/magnetics/images/sphx_glr_magnetic_field_001.png
    :alt: Diffusive Fullspace $H_x$, (a) |Re(empymod)|, (b) |Re(emg3d)|, (c) Error real part, (d) |Im(empymod)|, (e) |Im(emg3d)|, (f) Error imaginary part
    :class: sphx-glr-single-img






.. code-block:: default

    e3d_fs_hy = emg3d.get_receiver(pgrid, hfield.fy, (rx, ry, zrec))
    plot_result_rel(epm_fs_hy, e3d_fs_hy, x, r'Diffusive Fullspace $H_y$',
                    vmin=-8, vmax=-4, mode='abs')




.. image:: /gallery/magnetics/images/sphx_glr_magnetic_field_002.png
    :alt: Diffusive Fullspace $H_y$, (a) |Re(empymod)|, (b) |Re(emg3d)|, (c) Error real part, (d) |Im(empymod)|, (e) |Im(emg3d)|, (f) Error imaginary part
    :class: sphx-glr-single-img






.. code-block:: default

    e3d_fs_hz = emg3d.get_receiver(pgrid, hfield.fz, (rx, ry, zrec))
    plot_result_rel(epm_fs_hz, e3d_fs_hz, x, r'Diffusive Fullspace $H_z$',
                    vmin=-8, vmax=-4, mode='abs')




.. image:: /gallery/magnetics/images/sphx_glr_magnetic_field_003.png
    :alt: Diffusive Fullspace $H_z$, (a) |Re(empymod)|, (b) |Re(emg3d)|, (c) Error real part, (d) |Im(empymod)|, (e) |Im(emg3d)|, (f) Error imaginary part
    :class: sphx-glr-single-img






.. code-block:: default

    plot_lineplot_ex(x, x, e3d_fs_hx.real, epm_fs_hx.real, pgrid)




.. image:: /gallery/magnetics/images/sphx_glr_magnetic_field_004.png
    :alt: Inline and crossline $H_x$
    :class: sphx-glr-single-img






.. code-block:: default

    emg3d.Report()





.. only:: builder_html

    .. raw:: html

        <table style='border: 3px solid #ddd;'>
          <tr>
             <td style='text-align: center; font-weight: bold; font-size: 1.2em; border: 2px solid #fff;' colspan='6'>Wed Jul 29 22:39:42 2020 CEST</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>OS</td>
            <td style='text-align: left; border: 2px solid #fff;'>Linux</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>CPU(s)</td>
            <td style='text-align: left; border: 2px solid #fff;'>4</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>Machine</td>
            <td style='text-align: left; border: 2px solid #fff;'>x86_64</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>Architecture</td>
            <td style='text-align: left; border: 2px solid #fff;'>64bit</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>RAM</td>
            <td style='text-align: left; border: 2px solid #fff;'>15.5 GB</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>Environment</td>
            <td style='text-align: left; border: 2px solid #fff;'>Python</td>
          </tr>
          <tr>
             <td style='text-align: center; border: 2px solid #fff;' colspan='6'>Python 3.8.3 (default, Jul  2 2020, 16:21:59) 
        [GCC 7.3.0]</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>numpy</td>
            <td style='text-align: left; border: 2px solid #fff;'>1.18.5</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>scipy</td>
            <td style='text-align: left; border: 2px solid #fff;'>1.5.0</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>numba</td>
            <td style='text-align: left; border: 2px solid #fff;'>0.50.1</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>emg3d</td>
            <td style='text-align: left; border: 2px solid #fff;'>0.12.0</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>empymod</td>
            <td style='text-align: left; border: 2px solid #fff;'>2.0.2</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>xarray</td>
            <td style='text-align: left; border: 2px solid #fff;'>0.16.0</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>discretize</td>
            <td style='text-align: left; border: 2px solid #fff;'>0.4.15</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>h5py</td>
            <td style='text-align: left; border: 2px solid #fff;'>2.10.0</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>matplotlib</td>
            <td style='text-align: left; border: 2px solid #fff;'>3.2.2</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>IPython</td>
            <td style='text-align: left; border: 2px solid #fff;'>7.16.1</td>
            <td style= border: 2px solid #fff;'></td>
            <td style= border: 2px solid #fff;'></td>
            <td style= border: 2px solid #fff;'></td>
            <td style= border: 2px solid #fff;'></td>
          </tr>
          <tr>
             <td style='text-align: center; background-color: #ddd;border: 2px solid #fff;' colspan='6'>Intel(R) Math Kernel Library Version 2020.0.1 Product Build 20200208 for Intel(R) 64 architecture applications</td>
          </tr>
        </table>
        <br />
        <br />


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  51.533 seconds)

**Estimated memory usage:**  1172 MB


.. _sphx_glr_download_gallery_magnetics_magnetic_field.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: magnetic_field.py <magnetic_field.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: magnetic_field.ipynb <magnetic_field.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
