.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_gallery_reproducing_SEG-EAGE_3D_salt_model.py>`     to download the full example code
    .. rst-class:: sphx-glr-example-title

    .. _sphx_glr_gallery_reproducing_SEG-EAGE_3D_salt_model.py:


1. SEG-EAGE 3D Salt Model
=========================


In this example we reproduce the results by [Muld07]_, which uses the SEG/EAGE
salt model from [AmBK97]_.

Velocity to resistivity transform
---------------------------------

Quoting here the description of the velocity-to-resistivity transform used by
[Muld07]_:

    "The SEG/EAGE salt model (Aminzadeh et al. 1997), originally designed for
    seismic simulations, served as a template for a realistic subsurface model.
    Its dimensions are 13500 by 13480 by 4680 m. The seismic velocities of the
    model were replaced by resistivity values. The water velocity of 1.5 km/s
    was replaced by a resistivity of 0.3 Ohm m. Velocities above 4 km/s,
    indicative of salt, were replaced by 30 Ohm m. Basement, beyond 3660 m
    depth, was set to 0.002 Ohm m. The resistivity of the sediments was
    determined by :math:`(v/1700)^{3.88}` Ohm m, with the velocity v in m/s
    (Meju et al. 2003). For air, the resistivity was set to :math:`10^8` Ohm
    m."

Equation 1 of [MeGM03]_, is given by

.. math::
    :label: meju

    \log_{10}\rho = m \log_{10}V_P + c \ ,

where :math:`\rho` is resistivity, :math:`V_P` is P-wave velocity, and for
:math:`m` and :math:`c` 3.88 and -11 were used, respectively.

The velocity-to-resistivity transform uses therefore a Faust model ([Faus53]_)
with some additional constraints for water, salt, and basement.


.. code-block:: default

    import emg3d
    import joblib
    import zipfile
    import pyvista
    import numpy as np
    import matplotlib.pyplot as plt
    from matplotlib.colors import LogNorm
    plt.style.use('ggplot')









Velocity-to-resistivity transform
---------------------------------

The following cell loads the resistivity model ``res-model.lzma`` (~14 MB),
if it already exists in ``../data/SEG/``, or alternatively loads the velocity
model ``Saltf@@``, carries out the velocity-to-resistivity transform, and
stores the resistivity model.

You can get the data from the `SEG-website
<https://wiki.seg.org/wiki/SEG/EAGE_Salt_and_Overthrust_Models>`_ or via this
`direct link
<https://s3.amazonaws.com/open.source.geoscience/open_data/seg_eage_models_cd/Salt_Model_3D.tar.gz>`_.
The zip-file is 513.1 MB big. Unzip the archive, and place the file
``Salt_Model_3D/3-D_Salt_Model/VEL_GRIDS/SALTF.ZIP`` (20.0 MB) into
``../data/SEG/`` (or adjust the path in the following cell).


.. code-block:: default


    path = '../data/SEG/'
    try:
        # Get resistivities if we already computed them
        res = joblib.load(path+'res-model.lzma')

        # Get dimension
        nx, ny, nz = res.shape

    except FileNotFoundError:  # THE ORIGINAL DATA ARE REQUIRED!

        # Dimensions
        nx, ny, nz = 676, 676, 210

        # Extract Saltf@@ from SALTF.ZIP
        zipfile.ZipFile(path+'SALTF.ZIP', 'r').extract('Saltf@@', path=path)

        # Load data
        with open(path+'Saltf@@', 'r') as file:
            v = np.fromfile(file, dtype=np.dtype('float32').newbyteorder('>'))
            v = v.reshape(nx, ny, nz, order='F')

        # Velocity to resistivity transform for whole cube
        res = (v/1700)**3.88  # Sediment resistivity = 1

        # Overwrite basement resistivity from 3660 m onwards
        res[:, :, np.arange(nz)*20 > 3660] = 500.  # Resistivity of basement

        # Set sea-water to 0.3
        res[:, :, :15][v[:, :, :15] <= 1500] = 0.3

        # Fix salt resistivity
        res[v == 4482] = 30.

        # Save it in compressed form
        # THE SEG/EAGE salt-model uses positive z downwards; discretize positive
        # upwards. Hence:
        # => for res, use np.flip(res, 2) to flip the z-direction
        res = np.flip(res, 2)

        # Very fast, but not so effective (118.6 MB).
        # joblib.dump(res, './res-model', compress=True)

        # lzma: very slow, but very effective (~ 18.6 MB).
        joblib.dump(res, path+'res-model.lzma')

    # Create a discretize-mesh
    mesh = emg3d.TensorMesh(
            [np.ones(nx)*20., np.ones(ny)*20., np.ones(nz)*20.], x0='00N')
    models = {'res': np.log10(res.ravel('F'))}

    # Limit colour-range
    # We're cutting here the colour-spectrum at 50 Omega.m (affects only
    # the basement) to have a better resolution in the sediments.
    clim = np.log10([np.nanmin(res), 50])

    mesh






.. only:: builder_html

    .. raw:: html

        <table>
          <tr>
            <td style='font-weight: bold; font-size: 1.2em; text-align: center;' colspan='3'>TensorMesh</td>
            <td style='font-size: 1.2em; text-align: center;'colspan='4'>95,964,960 cells</td>
          </tr>
          <tr>
            <th></th>
            <th></th>
            <th colspan='2' style='padding: 5px 20px 5px 20px;'>MESH EXTENT</th>
            <th colspan='2' style='padding: 5px 20px 5px 20px;'>CELL WIDTH</th>
            <th style='padding: 5px 20px 5px 20px;'>FACTOR</th>
          </tr>
          <tr>
            <th style='padding: 5px 20px 5px 20px;'>dir</th>
            <th style='padding: 5px 20px 5px 20px;'>nC</th>
            <th style='padding: 5px 20px 5px 20px;'>min</th>
            <th style='padding: 5px 20px 5px 20px;'>max</th>
            <th style='padding: 5px 20px 5px 20px;'>min</th>
            <th style='padding: 5px 20px 5px 20px;'>max</th>
            <th style='padding: 5px 20px 5px 20px;'>max</th>
          </tr>
          <tr>
            <td style='padding: 5px 20px 5px 20px;'>x</td>
            <td style='padding: 5px 20px 5px 20px;'>676</td>
            <td style='padding: 5px 20px 5px 20px;'>0.00</td>
            <td style='padding: 5px 20px 5px 20px;'>13,520.00</td>
            <td style='padding: 5px 20px 5px 20px;'>20.00</td>
            <td style='padding: 5px 20px 5px 20px;'>20.00</td>
            <td style='padding: 5px 20px 5px 20px;'>1.00</td>
          </tr>
          <tr>
            <td style='padding: 5px 20px 5px 20px;'>y</td>
            <td style='padding: 5px 20px 5px 20px;'>676</td>
            <td style='padding: 5px 20px 5px 20px;'>0.00</td>
            <td style='padding: 5px 20px 5px 20px;'>13,520.00</td>
            <td style='padding: 5px 20px 5px 20px;'>20.00</td>
            <td style='padding: 5px 20px 5px 20px;'>20.00</td>
            <td style='padding: 5px 20px 5px 20px;'>1.00</td>
          </tr>
          <tr>
            <td style='padding: 5px 20px 5px 20px;'>z</td>
            <td style='padding: 5px 20px 5px 20px;'>210</td>
            <td style='padding: 5px 20px 5px 20px;'>-4,200.00</td>
            <td style='padding: 5px 20px 5px 20px;'>0.00</td>
            <td style='padding: 5px 20px 5px 20px;'>20.00</td>
            <td style='padding: 5px 20px 5px 20px;'>20.00</td>
            <td style='padding: 5px 20px 5px 20px;'>1.00</td>
          </tr>
        </table>

        <br />
        <br />

3D-slicer
---------


.. code-block:: default


    mesh.plot_3d_slicer(models['res'], zslice=-2000, clim=clim)




.. image:: /gallery/reproducing/images/sphx_glr_SEG-EAGE_3D_salt_model_001.png
    :alt: SEG EAGE 3D salt model
    :class: sphx-glr-single-img





PyVista plot
------------

Create an interactive 3D render of the data.


.. code-block:: default


    dataset = mesh.toVTK(models)

    # Create the rendering scene and add a grid axes
    p = pyvista.Plotter(notebook=True)
    p.show_grid(location='outer')

    dparams = {'rng': clim, 'cmap': 'viridis', 'show_edges': False}
    # Add spatially referenced data to the scene
    xyz = (5000, 6000, -3200)
    p.add_mesh(dataset.slice('x', xyz), name='x-slice', **dparams)
    p.add_mesh(dataset.slice('y', xyz), name='y-slice', **dparams)
    p.add_mesh(dataset.slice('z', xyz), name='z-slice', **dparams)

    # Get the salt body
    p.add_mesh(dataset.threshold([1.47, 1.48]), name='vol', **dparams)

    # Show the scene!
    p.camera_position = [(27000, 37000, 5800), (6600, 6600, -3300), (0, 0, 1)]
    p.show()




.. image:: /gallery/reproducing/images/sphx_glr_SEG-EAGE_3D_salt_model_002.png
    :alt: SEG EAGE 3D salt model
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <PIL.Image.Image image mode=RGB size=1024x768 at 0x7F29A6F6C3D0>




Forward modelling
-----------------

Survey parameters
`````````````````


.. code-block:: default


    src = [6400, 6600, 6500, 6500, -50, -50]  # source location
    freq = 1.0                                # Frequency








Initialize computation mesh
```````````````````````````


.. code-block:: default


    # Get computation domain as a function of frequency (resp., skin depth)
    hx_min, xdomain = emg3d.meshes.get_domain(
            x0=6500, freq=freq, limits=[0, 13500], min_width=[5, 100])
    hz_min, zdomain = emg3d.meshes.get_domain(
            freq=freq, limits=[-4180, 0], min_width=[5, 20], fact_pos=40)

    # Create stretched grid
    nx = 2**7
    hx = emg3d.meshes.get_stretched_h(hx_min, xdomain, nx, 6500)
    hy = emg3d.meshes.get_stretched_h(hx_min, xdomain, nx, 6500)
    hz = emg3d.meshes.get_stretched_h(hz_min, zdomain, nx, x0=-100, x1=0)
    grid = emg3d.TensorMesh(
            [hx, hy, hz], x0=(xdomain[0], xdomain[0], zdomain[0]))
    grid






.. only:: builder_html

    .. raw:: html

        <table>
          <tr>
            <td style='font-weight: bold; font-size: 1.2em; text-align: center;' colspan='3'>TensorMesh</td>
            <td style='font-size: 1.2em; text-align: center;'colspan='4'>2,097,152 cells</td>
          </tr>
          <tr>
            <th></th>
            <th></th>
            <th colspan='2' style='padding: 5px 20px 5px 20px;'>MESH EXTENT</th>
            <th colspan='2' style='padding: 5px 20px 5px 20px;'>CELL WIDTH</th>
            <th style='padding: 5px 20px 5px 20px;'>FACTOR</th>
          </tr>
          <tr>
            <th style='padding: 5px 20px 5px 20px;'>dir</th>
            <th style='padding: 5px 20px 5px 20px;'>nC</th>
            <th style='padding: 5px 20px 5px 20px;'>min</th>
            <th style='padding: 5px 20px 5px 20px;'>max</th>
            <th style='padding: 5px 20px 5px 20px;'>min</th>
            <th style='padding: 5px 20px 5px 20px;'>max</th>
            <th style='padding: 5px 20px 5px 20px;'>max</th>
          </tr>
          <tr>
            <td style='padding: 5px 20px 5px 20px;'>x</td>
            <td style='padding: 5px 20px 5px 20px;'>128</td>
            <td style='padding: 5px 20px 5px 20px;'>0.00</td>
            <td style='padding: 5px 20px 5px 20px;'>13,482.75</td>
            <td style='padding: 5px 20px 5px 20px;'>55.13</td>
            <td style='padding: 5px 20px 5px 20px;'>182.61</td>
            <td style='padding: 5px 20px 5px 20px;'>1.02</td>
          </tr>
          <tr>
            <td style='padding: 5px 20px 5px 20px;'>y</td>
            <td style='padding: 5px 20px 5px 20px;'>128</td>
            <td style='padding: 5px 20px 5px 20px;'>0.00</td>
            <td style='padding: 5px 20px 5px 20px;'>13,482.75</td>
            <td style='padding: 5px 20px 5px 20px;'>55.13</td>
            <td style='padding: 5px 20px 5px 20px;'>182.61</td>
            <td style='padding: 5px 20px 5px 20px;'>1.02</td>
          </tr>
          <tr>
            <td style='padding: 5px 20px 5px 20px;'>z</td>
            <td style='padding: 5px 20px 5px 20px;'>128</td>
            <td style='padding: 5px 20px 5px 20px;'>-4,180.00</td>
            <td style='padding: 5px 20px 5px 20px;'>11,250.16</td>
            <td style='padding: 5px 20px 5px 20px;'>20.00</td>
            <td style='padding: 5px 20px 5px 20px;'>516.82</td>
            <td style='padding: 5px 20px 5px 20px;'>1.05</td>
          </tr>
        </table>

        <br />
        <br />

Put the salt model onto the modelling mesh
``````````````````````````````````````````


.. code-block:: default


    # Interpolate resistivities from fine mesh to coarser grid
    cres = emg3d.maps.grid2grid(mesh, res, grid, 'volume')

    # Create model
    model = emg3d.Model(grid, property_x=cres, mapping='Resistivity')

    # Set air resistivity
    iz = np.argmin(np.abs(grid.vectorNz))
    model.property_x[:, :, iz:] = 1e8

    # Ensure at least top layer is water
    model.property_x[:, :, iz] = 0.3

    cmodels = {'res': np.log10(model.property_x.ravel('F'))}

    grid.plot_3d_slicer(
            cmodels['res'], zslice=-2000, zlim=(-4180, 500),
            clim=np.log10([np.nanmin(model.property_x), 50]))




.. image:: /gallery/reproducing/images/sphx_glr_SEG-EAGE_3D_salt_model_003.png
    :alt: SEG EAGE 3D salt model
    :class: sphx-glr-single-img





Solve the system
````````````````


.. code-block:: default


    # Source field
    sfield = emg3d.get_source_field(grid, src, freq, 0)

    pfield = emg3d.solve(
        grid, model, sfield,
        sslsolver=True,
        semicoarsening=False,
        linerelaxation=False,
        verb=3)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    :: emg3d START :: 21:48:07 :: v0.12.0

       MG-cycle       : 'F'                 sslsolver : 'bicgstab'
       semicoarsening : False [0]           tol       : 1e-06
       linerelaxation : False [0]           maxit     : 50 (1)
       nu_{i,1,c,2}   : 0, 2, 1, 2          verb      : 3
       Original grid  : 128 x 128 x 128     => 2,097,152 cells
       Coarsest grid  :   2 x   2 x   2     => 8 cells
       Coarsest level :   6 ;   6 ;   6   

       [hh:mm:ss]  rel. error            solver              MG          l s

           h_
          2h_ \                                        /
          4h_  \                            /\        / 
          8h_   \                  /\      /  \      /  
         16h_    \          /\    /  \    /    \    /   
         32h_     \    /\  /  \  /    \  /      \  /    
         64h_      \/\/  \/    \/      \/        \/     

       [21:48:17]   1.591e-01  after                       1 F-cycles    0 0
       [21:48:29]   3.299e-02  after                       2 F-cycles    0 0
       [21:48:30]   2.291e-02  after   1 bicgstab-cycles
       [21:48:40]   6.756e-03  after                       3 F-cycles    0 0
       [21:48:50]   1.035e-03  after                       4 F-cycles    0 0
       [21:48:50]   8.113e-04  after   2 bicgstab-cycles
       [21:49:00]   3.055e-04  after                       5 F-cycles    0 0
       [21:49:10]   6.347e-05  after                       6 F-cycles    0 0
       [21:49:11]   4.581e-05  after   3 bicgstab-cycles
       [21:49:21]   1.753e-05  after                       7 F-cycles    0 0
       [21:49:31]   4.368e-06  after                       8 F-cycles    0 0
       [21:49:32]   3.969e-06  after   4 bicgstab-cycles
       [21:49:41]   2.619e-06  after                       9 F-cycles    0 0
       [21:49:52]   1.626e-06  after                      10 F-cycles    0 0
       [21:49:52]   1.127e-06  after   5 bicgstab-cycles
       [21:50:02]   8.366e-07  after                      11 F-cycles    0 0
       [21:50:03]   7.448e-07  after   6 bicgstab-cycles

       > CONVERGED
       > Solver steps     : 6
       > MG prec. steps   : 11
       > Final rel. error : 7.448e-07

    :: emg3d END   :: 21:50:03 :: runtime = 0:01:56






.. code-block:: default


    grid.plot_3d_slicer(
        pfield.fx.ravel('F'), zslice=-2000, zlim=(-4180, 500),
        view='abs', v_type='Ex',
        clim=[1e-16, 1e-9], pcolor_opts={'norm': LogNorm()})




.. image:: /gallery/reproducing/images/sphx_glr_SEG-EAGE_3D_salt_model_004.png
    :alt: SEG EAGE 3D salt model
    :class: sphx-glr-single-img






.. code-block:: default


    # Interpolate for a "more detailed" image
    x = grid.vectorCCx
    y = grid.vectorCCy
    rx = np.repeat([x, ], np.size(x), axis=0)
    ry = rx.transpose()
    rz = -2000
    data = emg3d.get_receiver(grid, pfield.fx, (rx, ry, rz))

    # Colour limits
    vmin, vmax = -16, -10.5

    # Create a figure
    fig, axs = plt.subplots(figsize=(8, 5), nrows=1, ncols=2)
    axs = axs.ravel()
    plt.subplots_adjust(hspace=0.3, wspace=0.3)

    titles = [r'|Real|', r'|Imaginary|']
    dat = [np.log10(np.abs(data.real)), np.log10(np.abs(data.imag))]

    for i in range(2):
        plt.sca(axs[i])
        axs[i].set_title(titles[i])
        axs[i].set_xlim(min(x)/1000, max(x)/1000)
        axs[i].set_ylim(min(x)/1000, max(x)/1000)
        axs[i].axis('equal')
        cs = axs[i].pcolormesh(x/1000, x/1000, dat[i], vmin=vmin, vmax=vmax,
                               linewidth=0, rasterized=True,)
        plt.xlabel('Inline Offset (km)')
        plt.ylabel('Crossline Offset (km)')

    # Colorbar
    # fig.colorbar(cf0, ax=axs[0], label=r'$\log_{10}$ Amplitude (V/m)')

    # Plot colorbar
    cax, kw = plt.matplotlib.colorbar.make_axes(
            axs, location='bottom', fraction=.05, pad=0.2, aspect=30)
    cb = plt.colorbar(cs, cax=cax, label=r"$\log_{10}$ Amplitude (V/m)", **kw)

    # Title
    fig.suptitle(f"SEG/EAGE Salt Model, depth = {rz/1e3} km.", y=1, fontsize=16)

    plt.show()




.. image:: /gallery/reproducing/images/sphx_glr_SEG-EAGE_3D_salt_model_005.png
    :alt: SEG/EAGE Salt Model, depth = -2.0 km., |Real|, |Imaginary|
    :class: sphx-glr-single-img






.. code-block:: default


    emg3d.Report(pyvista)





.. only:: builder_html

    .. raw:: html

        <table style='border: 3px solid #ddd;'>
          <tr>
             <td style='text-align: center; font-weight: bold; font-size: 1.2em; border: 2px solid #fff;' colspan='6'>Fri Jul 31 21:50:05 2020 CEST</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>OS</td>
            <td style='text-align: left; border: 2px solid #fff;'>Linux</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>CPU(s)</td>
            <td style='text-align: left; border: 2px solid #fff;'>4</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>Machine</td>
            <td style='text-align: left; border: 2px solid #fff;'>x86_64</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>Architecture</td>
            <td style='text-align: left; border: 2px solid #fff;'>64bit</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>RAM</td>
            <td style='text-align: left; border: 2px solid #fff;'>15.5 GB</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>Environment</td>
            <td style='text-align: left; border: 2px solid #fff;'>Python</td>
          </tr>
          <tr>
             <td style='text-align: center; border: 2px solid #fff;' colspan='6'>Python 3.8.3 (default, Jul  2 2020, 16:21:59) 
        [GCC 7.3.0]</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>pyvista</td>
            <td style='text-align: left; border: 2px solid #fff;'>0.25.3</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>numpy</td>
            <td style='text-align: left; border: 2px solid #fff;'>1.18.5</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>scipy</td>
            <td style='text-align: left; border: 2px solid #fff;'>1.5.0</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>numba</td>
            <td style='text-align: left; border: 2px solid #fff;'>0.50.1</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>emg3d</td>
            <td style='text-align: left; border: 2px solid #fff;'>0.12.0</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>empymod</td>
            <td style='text-align: left; border: 2px solid #fff;'>2.0.2</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>xarray</td>
            <td style='text-align: left; border: 2px solid #fff;'>0.16.0</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>discretize</td>
            <td style='text-align: left; border: 2px solid #fff;'>0.4.15</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>h5py</td>
            <td style='text-align: left; border: 2px solid #fff;'>2.10.0</td>
          </tr>
          <tr>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>matplotlib</td>
            <td style='text-align: left; border: 2px solid #fff;'>3.2.2</td>
            <td style='text-align: right; background-color: #ccc; border: 2px solid #fff;'>IPython</td>
            <td style='text-align: left; border: 2px solid #fff;'>7.16.1</td>
            <td style= border: 2px solid #fff;'></td>
            <td style= border: 2px solid #fff;'></td>
          </tr>
          <tr>
             <td style='text-align: center; background-color: #ddd;border: 2px solid #fff;' colspan='6'>Intel(R) Math Kernel Library Version 2020.0.1 Product Build 20200208 for Intel(R) 64 architecture applications</td>
          </tr>
        </table>
        <br />
        <br />


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 2 minutes  45.374 seconds)

**Estimated memory usage:**  2917 MB


.. _sphx_glr_download_gallery_reproducing_SEG-EAGE_3D_salt_model.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: SEG-EAGE_3D_salt_model.py <SEG-EAGE_3D_salt_model.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: SEG-EAGE_3D_salt_model.ipynb <SEG-EAGE_3D_salt_model.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
